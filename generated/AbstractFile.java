/*
 * generated by Fujaba - CodeGen2
 */
import de.uni_kassel.features.annotation.util.Property; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.features.ReferenceHandler; // requires Fujaba5/libs/features.jar in classpath
import java.util.*;
import de.upb.tools.fca.*; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import java.io.File;


public abstract class AbstractFile
{



   protected  AbstractFile ()
   {
   }

   /**
    * <pre>
    *           0..n     has     0..n
    * AbstractFile ------------------------- AbstractDirectory
    *           abstractFile               abstractDirectory
    * </pre>
    */
   public static final String PROPERTY_ABSTRACT_DIRECTORY = "abstractDirectory";

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY, partner = AbstractDirectory.PROPERTY_ABSTRACT_FILE, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<AbstractDirectory> abstractDirectory;

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public Set<? extends AbstractDirectory> getAbstractDirectory()
   {
      return ((this.abstractDirectory == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.abstractDirectory));
   }

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public boolean addToAbstractDirectory (AbstractDirectory value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.abstractDirectory == null)
         {
            this.abstractDirectory = new FHashSet<AbstractDirectory> ();

         }
      
         changed = this.abstractDirectory.add (value);
         if (changed)
         {
            value.addToAbstractFile (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public AbstractFile withAbstractDirectory (AbstractDirectory value)
   {
      addToAbstractDirectory (value);
      return this;
   }

   public AbstractFile withoutAbstractDirectory (AbstractDirectory value)
   {
      removeFromAbstractDirectory (value);
      return this;
   }


   public boolean removeFromAbstractDirectory (AbstractDirectory value)
   {
      boolean changed = false;

      if ((this.abstractDirectory != null) && (value != null))
      {
      
         changed = this.abstractDirectory.remove (value);
         if (changed)
         {
            value.removeFromAbstractFile (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public void removeAllFromAbstractDirectory (){
   
      AbstractDirectory tmpValue;
      Iterator<? extends AbstractDirectory> iter = this.iteratorOfAbstractDirectory ();
      while (iter.hasNext ())
      {
         tmpValue = (AbstractDirectory) iter.next ();
         this.removeFromAbstractDirectory (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public boolean hasInAbstractDirectory (AbstractDirectory value)
   {
      return ((this.abstractDirectory != null) &&
              (value != null) &&
              this.abstractDirectory.contains (value));
   }

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public Iterator<? extends AbstractDirectory> iteratorOfAbstractDirectory ()
   {
      return ((this.abstractDirectory == null)
              ? FEmptyIterator.<AbstractDirectory>get ()
              : this.abstractDirectory.iterator ());
   }

   @Property( name = PROPERTY_ABSTRACT_DIRECTORY )
   public int sizeOfAbstractDirectory ()
   {
      return ((this.abstractDirectory == null)
              ? 0
              : this.abstractDirectory.size ());
   }

   public abstract void accept (Visitor visitor );

   public abstract File getFileSize ();

   public abstract String getName ();

   public void removeYou()
   {
      this.removeAllFromAbstractDirectory ();
   }
}


